import Component from '@glimmer/component';
import { action } from '@ember/object';
import { A } from '@ember/array';
import { tracked } from '@glimmer/tracking';
import { inject as service } from '@ember/service';
import EmberObject from '@ember/object';
import L from "leaflet";

export default class MapComponent extends Component {

  @service dataColors;
  @service deviceContext;
  @service fastboot;
  @service searchParameters;
  @service store;

  @tracked activeFeature = null;
  @tracked activeVectorTile = null;
  @tracked baseLayer;
  @tracked map;

  inactiveIcon(vectorFeature) {
    return L.divIcon({
      html: `<div><i class="fas fa-map-marker-alt"></i></div>`,
      className: `leaflet-marker-icon leaflet-div-icon leaflet-zoom-animated leaflet-interactive atlm-map-marker ${vectorFeature.color.name}`,
    });
  }

  activeIcon(vectorFeature) {
    return L.divIcon({
      html: `<div id="data-layer-${vectorFeature.id}"><i class="fas fa-map-marker-alt"></i></div>`,
      className: `leaflet-marker-icon leaflet-div-icon leaflet-zoom-animated leaflet-interactive atlm-map-marker ${vectorFeature.color.name} active`
    });
  }

  getMappedColor(vector, feature) {
    let color = '#263238';
    if (vector.marker && vector.get('vectorLayer.geometryType') != 'Point') {
      return this.dataColors.shapeColors[vector.marker].hex;
    } else if (vector.colorMap && Object.keys(vector.colorMap).length > 0) {
      const property = feature.geometry.properties[vector.property];
      Object.keys(vector.colorMap).forEach(key => {
        if (isNaN(property) && property == key) {
          color = vector.colorMap[key].color;
        }
        else if (property >= vector.colorMap[key].bottom && property <= vector.colorMap[key].top) {
          color = vector.colorMap[key].color;
        }
      });
    }
    return color;
  }

  getLineColor(vector, feature) {
    if (vector.get('vectorLayer.geometryType') == 'LineString') {
      return this.getMappedColor(vector, feature);
    } else {
      return '#263238';
    }
  }

  @action
  activateFeature(event) {
    console.log("MapComponent -> activateFeature -> event", event.target)
    // this.clearActiveFeature();
    // let layer = EmberObject.create({});
    // layer.setProperties(
    //   {
    //     leafletLayer: event.target,
    //     vectorLayer: {
    //       properties: event.target.feature.geometry.properties,
    //     },
    //     active: true
    //   }
    // );
    // this.activeFeature = layer.leafletLayer.vectorLayer;
    // console.log("MapComponent -> activateFeature -> layer", this.activeFeature)
  }

  @action
  style(vector, feature) {
    let featureColor = this.getMappedColor(vector, feature);
    let lineColor = this.getLineColor(vector, feature);

    return {
      fillColor: featureColor,
      color: lineColor
    };
  }

  @action
  onEachFeature(vector, feature, layer) {
    const vectorLayer = vector.get('vectorLayer');
    vectorLayer.get('leafletFeatures').push(feature);
    vectorLayer.setProperties({ leafletLayer: layer });

    const vectorFeature = this.store.createRecord(
      'vectorFeature',
      {
        vectorLayer,
        geojson: feature,
        layerTitle: vectorLayer.get('title'),
        color: vector.color,
        description: feature.properties.description,
        leafObject: layer,
        geometryType: layer.feature.geometry.geometries.firstObject.type
      }
    );

    layer.vectorFeature = vectorFeature;

    layer.vectorLayer = vectorLayer;

    layer.on('click', event => {
      const leafletMarker = event.layer;
      this.clearActiveFeature();
      layer.vectorFeature.setProperties({
        active: true,
        leafletMarker
      });
      if (vectorFeature.geometryType == 'Point') {
        leafletMarker.setIcon(this.activeIcon(layer.vectorFeature));
      }
      this.activeFeature = layer.vectorFeature;
    });

    // layer.on('keyup', event => {
    //   if (event.originalEvent.key == 'Enter') {
    //     this.clearActiveFeature();
    //     this.activeFeature = vectorFeature;
    //     if (vectorFeature.geometryType == 'Point') {
    //       this.activeFeature.leafletMarker.setIcon(
    //         this.activeIcon(this.activeFeature)
    //       );
    //     }
    //  }
    // });
  }

  @action
  clearActiveFeatureKey(event) {
    // if (!event || event.type != 'keyup') return;
    if (event && event.type == 'keyup' && event.key == 'Escape' || event.key == 'Enter' && event.target.id == 'atlm-close-popup-button') {
      this.clearActiveFeature();
    }
  }

  @action
  clearActiveFeature() {
    if (this.activeVectorTile) {
      this.deactivateVT();
    }

    if (this.activeFeature) {
      if (this.activeFeature.geometryType == 'Point') {
        this.clearActivePoint();
      }
      this.activeFeature.setProperties({
        active: false
      });
    }
    this.activeFeature = null;
  }

  clearActivePoint() {
    this.activeFeature.leafletMarker.setIcon(
      this.inactiveIcon(this.activeFeature)
    );
  }

  @action
  captureBounds() {
    if (this.map) {
      this.searchParameters.currentBounds = this.map.getBounds();
    }
  }

  @action
  addMarker(vectorFeature, layer, feature/*, point*/) {
    let marker = L.marker(feature);
    feature['marker'] = marker;
    marker.setIcon(
      this.inactiveIcon(vectorFeature),
    );
    return marker;
  }

  @action
  rasterAdded(raster, event) {
    raster.setProperties({ leafletObject: event.sourceTarget, onMap: true });
  }

  @action
  geojsonAdded(vectorLayer) {
    vectorLayer.setProperties({ onMap: true });
  }

  @action
  initMap(event) {
    const map = event.target;
    this.args.project.setProperties({
      leafletMap: map
    });
    if(this.deviceContext.isDesktop) {
      map.zoomControl.setPosition('bottomleft');
    } else {
      map.zoomControl.remove();
    }
    this.args.project.get('vectors').forEach(vector => {
      map.createPane(
        vector.get('vectorLayer.name')
      );
      let pane = map.getPane(vector.get('vectorLayer.name'));
      pane.style.zIndex = 500 - (vector.order * 10);
      pane.classList.add('leaflet-overlay-pane');
      vector.setProperties({
        leafletPane: pane
      });
    });
    this.map = map;
    this.captureBounds();
  }

  @action
  baseChange(newBaseLayer) {
    if (!this.baseLayer) {
      this.baseLayer = newBaseLayer;
    } else if (newBaseLayer != this.baseLayer) {
      this.baseLayer.leafletObjects.forEach(layer => {
        layer.remove();
      });
      this.baseLayer.leafletObjects = A([]);
      this.baseLayer = newBaseLayer;
    }
  }

  @action
  baseChanged(event) {
    this.baseLayer.leafletObjects.push(event.target);
  }

  @action
  styleVectorTile(layer, colorMap, properties) {
    let style = L.Path.prototype.options;
    const prop = layer.property;
    Object.keys(colorMap).forEach(key => {
      if (isNaN(properties[prop]) && properties[prop] == key) {
        return {
          color: colorMap[key].color,
          fillColor: colorMap[key].color,
          fill: true,
          fillOpacity:layer.get('vectorLayer.opacity') / 100
        };
      }
      else if (properties[prop] >= colorMap[key].bottom && properties[prop] <= colorMap[key].top) {
        style = {
          color: 'darkgray',
          fillColor: colorMap[key].color,
          fill: true,
          fillOpacity: layer.get('vectorLayer.opacity') / 100
        };
      }
    });
    return style;
  }

  @action
  activateVT(vector, event) {
    let layer = EmberObject.create(event.layer);

    layer.setProperties(
      {
        name: layer.properties.NAME,
        layer: event.target
      }
    );

    layer.vectorLayer = vector.get('vectorLayer');
    let style = layer.options;
    style.fillOpacity = 1;

    if (this.activeVectorTile) {
      event.target.resetFeatureStyle(this.activeVectorTile);
    }

    this.activeFeature = layer;

    this.activeVectorTile = layer.properties.NAME;

    event.target.setFeatureStyle(
      event.layer.properties.NAME,
      style
    );
  }

  deactivateVT() {
    this.activeFeature.layer.resetFeatureStyle(this.activeVectorTile);
    this.activeVectorTile = null;
  }
}
